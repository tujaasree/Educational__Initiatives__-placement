import java.time.LocalTime;
import java.util.*;
import java.util.logging.*;
import java.util.stream.Collectors;

enum Priority {
    HIGH, MEDIUM, LOW
}

class Task {
    private String description;
    private LocalTime startTime;
    private LocalTime endTime;
    private Priority priority;
    private boolean completed;

    public Task(String description, LocalTime startTime, LocalTime endTime, Priority priority) {
        this.description = description;
        this.startTime = startTime;
        this.endTime = endTime;
        this.priority = priority;
        this.completed = false;
    }

    public String getDescription() { return description; }
    public LocalTime getStartTime() { return startTime; }
    public LocalTime getEndTime() { return endTime; }
    public Priority getPriority() { return priority; }
    public boolean isCompleted() { return completed; }
    public void setCompleted(boolean completed) { this.completed = completed; }

    @Override
    public String toString() {
        return String.format("%s-%s %s (%s)%s",
            startTime, endTime, description, priority,
            completed ? " [Completed]" : "");
    }
}

class TaskFactory {
    public static Task createTask(String desc, String start, String end, String priority) {
        try {
            LocalTime startTime = LocalTime.parse(start.substring(0, 2) + ":" + start.substring(2));
            LocalTime endTime = LocalTime.parse(end.substring(0, 2) + ":" + end.substring(2));
            Priority prio = Priority.valueOf(priority.toUpperCase());
            if (startTime.isAfter(endTime) || startTime.equals(endTime)) {
                throw new IllegalArgumentException("Start time must be before end time");
            }
            return new Task(desc, startTime, endTime, prio);
        } catch (Exception e) {
            throw new IllegalArgumentException("Invalid input for creating task: " + e.getMessage());
        }
    }
}

interface ScheduleObserver {
    void notifyConflict(Task existingTask, Task newTask);
}

class ConflictLoggerObserver implements ScheduleObserver {
    private static final Logger logger = Logger.getLogger(ConflictLoggerObserver.class.getName());

    @Override
    public void notifyConflict(Task existingTask, Task newTask) {
        logger.warning("Conflict: New task " + newTask + " overlaps with " + existingTask);
        System.out.println("Task conflicts with existing task: " + existingTask.getDescription());
    }
}

class MotivationProvider {
    private static final String[] MOTIVATIONS = {
        "Aim for the moon, even if you miss you’ll land among the stars.",
        "The stars don’t just wait for you—they expect you to shine.",
        "Lift-off isn’t just a command, it’s an attitude!",
        "Every asteroid has a silver lining.",
        "Astronauts don’t wait for opportunities, they create them."
    };

    public static String randomMotivation() {
        Random rand = new Random();
        return MOTIVATIONS[rand.nextInt(MOTIVATIONS.length)];
    }

    public static String motivateCommandResponse() {
        return "Astronaut Tip: “" + randomMotivation() + "”";
    }
}

class ScheduleManager {
    private static ScheduleManager instance = null;
    private final List<Task> tasks = new ArrayList<>();
    private final List<ScheduleObserver> observers = new ArrayList<>();

    private ScheduleManager() {}

    public static ScheduleManager getInstance() {
        if (instance == null) {
            instance = new ScheduleManager();
        }
        return instance;
    }

    public void addObserver(ScheduleObserver observer) {
        observers.add(observer);
    }

    public void addTask(Task newTask) {
        for (Task task : tasks) {
            if (isOverlap(task, newTask)) {
                observers.forEach(o -> o.notifyConflict(task, newTask));
                throw new RuntimeException("Task conflict detected.");
            }
        }
        if (consecutiveHighPriorityCount(newTask) > 2) {
            System.out.println("Warning: You have scheduled more than two HIGH priority tasks back-to-back. A rest slot is recommended.");
        }
        tasks.add(newTask);
        System.out.println("Task added successfully.");
    }

    public void removeTask(String desc) {
        boolean removed = tasks.removeIf(t -> t.getDescription().equalsIgnoreCase(desc));
        if (removed) {
            System.out.println("Task removed successfully.");
        } else {
            throw new RuntimeException("Task not found.");
        }
    }

    public void completeTask(String desc) {
        Optional<Task> taskOpt = tasks.stream()
            .filter(t -> t.getDescription().equalsIgnoreCase(desc))
            .findFirst();
        if (taskOpt.isPresent()) {
            Task task = taskOpt.get();
            if (task.isCompleted()) {
                System.out.println("Task already completed.");
            } else {
                task.setCompleted(true);
                System.out.println("Task '" + task.getDescription() + "' marked as completed. " + completionRate());
            }
        } else {
            throw new RuntimeException("Task not found.");
        }
    }

    public void viewTasks() {
        System.out.println("Daily Schedule:");
        System.out.println("Motivation: \"" + MotivationProvider.randomMotivation() + "\"");
        if (tasks.isEmpty()) {
            System.out.println("No tasks scheduled for the day.");
            return;
        }
        tasks.stream()
            .sorted(Comparator.comparing(Task::getStartTime))
            .forEach(System.out::println);
        System.out.println("Completion: " + completionRate());
    }

    public void viewTasks(String filter) {
        if (filter.equalsIgnoreCase("completed")) {
            System.out.println("Completed Tasks:");
            tasks.stream()
                .filter(Task::isCompleted)
                .sorted(Comparator.comparing(Task::getStartTime))
                .forEach(System.out::println);
        } else if (Arrays.stream(Priority.values()).anyMatch(p -> p.name().equalsIgnoreCase(filter))) {
            Priority prio = Priority.valueOf(filter.toUpperCase());
            System.out.println(prio + "-Priority Tasks:");
            tasks.stream()
                .filter(t -> t.getPriority() == prio)
                .sorted(Comparator.comparing(Task::getStartTime))
                .forEach(System.out::println);
        } else {
            System.out.println("Unknown filter.");
        }
    }

    public void viewStats() {
        long totalTasks = tasks.size();
        long completedTasks = tasks.stream().filter(Task::isCompleted).count();
        double completionPercentage = totalTasks == 0 ? 0 : (completedTasks * 100.0 / totalTasks);
        System.out.printf("Tasks scheduled: %d, Tasks completed: %d, Completion rate: %.2f%%%n",
            totalTasks, completedTasks, completionPercentage);
    }

    private String completionRate() {
        long totalTasks = tasks.size();
        long completedTasks = tasks.stream().filter(Task::isCompleted).count();
        if (totalTasks == 0) return "0% day complete!";
        double perc = (completedTasks * 100.0) / totalTasks;
        return String.format("%.0f%% day complete!", perc);
    }

    private boolean isOverlap(Task t1, Task t2) {
        return !(t1.getEndTime().isBefore(t2.getStartTime()) || t2.getEndTime().isBefore(t1.getStartTime()));
    }

    private int consecutiveHighPriorityCount(Task newTask) {
        List<Task> sorted = new ArrayList<>(tasks);
        sorted.add(newTask);
        sorted.sort(Comparator.comparing(Task::getStartTime));
        int count = 0;
        for (int i = 0; i < sorted.size(); i++) {
            Task t = sorted.get(i);
            if (t.getPriority() == Priority.HIGH) {
                count++;
                if (count > 2) return count;
            } else {
                count = 0;
            }
        }
        return count;
    }
}

public class AstronautScheduleApp {
    private static final Logger logger = Logger.getLogger(AstronautScheduleApp.class.getName());

    public static void main(String[] args) {
        ScheduleManager manager = ScheduleManager.getInstance();
        manager.addObserver(new ConflictLoggerObserver());

        Scanner sc = new Scanner(System.in);

        System.out.println("Welcome to Astronaut Daily Schedule Organizer!");
        System.out.println("Available commands:");
        System.out.println("add Task,<desc>,<start HHmm>,<end HHmm>,<priority>");
        System.out.println("remove task,<desc>");
        System.out.println("complete task,<desc>");
        System.out.println("view tasks [<priority/completed>]");
        System.out.println("view stats");
        System.out.println("motivate");
        System.out.println("exit");

        boolean running = true;
        while (running) {
            System.out.print("\nEnter command: ");
            String input = sc.nextLine().trim();

            try {
                if (input.equalsIgnoreCase("exit")) {
                    running = false;
                } else if (input.startsWith("add Task,")) {
                    String[] parts = input.split(",", 5);
                    if (parts.length < 5) {
                        throw new IllegalArgumentException("Invalid add command format.");
                    }
                    Task t = TaskFactory.createTask(parts[1], parts[2], parts[3], parts[4]);
                    manager.addTask(t);
                } else if (input.startsWith("remove task,")) {
                    String desc = input.substring("remove task,".length()).trim();
                    manager.removeTask(desc);
                } else if (input.startsWith("complete task,")) {
                    String desc = input.substring("complete task,".length()).trim();
                    manager.completeTask(desc);
                } else if (input.startsWith("view tasks")) {
                    String rest = input.substring("view tasks".length()).trim();
                    if (rest.isEmpty()) {
                        manager.viewTasks();
                    } else {
                        manager.viewTasks(rest);
                    }
                } else if (input.equalsIgnoreCase("view stats")) {
                    manager.viewStats();
                } else if (input.equalsIgnoreCase("motivate")) {
                    System.out.println(MotivationProvider.motivateCommandResponse());
                } else {
                    System.out.println("Unknown command. Please try again.");
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, e.getMessage());
                System.out.println("Error: " + e.getMessage());
            }
        }

        System.out.println("Exiting Astronaut Daily Schedule Organizer... Have a great day!");
        sc.close();
    }
}
